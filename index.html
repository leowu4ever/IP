<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta name="format-detection" content="telephone=no" />
		<script>if (window.hyper && window.hyper.log) { console.log = hyper.log }</script>
		<script src="cordova.js"></script>
		<script src="libs/crafty.js"></script>
   		<script src="src/game.js"></script>
		<script src="src/gesture.js"></script>
   		<script src="src/game.css"></script>
		<script src="libs/evothings/evothings.js"></script>
		<script src="libs/evothings/ui/ui.js"></script>
		<script src="libs/evothings/tisensortag/tisensortag.js"></script>
		<script>window.addEventListener('load', Game.start)</script>
	</head>
    <body style="background-image:url(assets/background.png)">
		<button onclick="connect()" class="green">connect</button>
		<button onclick="disconnect()" class="red">disconnect</button>
		<span id="StatusData">Press Connect to find the nearest SensorTag</span>
		<span id="AccelerometerData">[Waiting for value]</span>
		<span id="Result">Not recording</span>
	</body>
	
	<script>
		var sensortag
		function initialiseSensorTag()
		{
			// Create SensorTag CC2650 instance.
			sensortag = evothings.tisensortag.createInstance(evothings.tisensortag.CC2650_BLUETOOTH_SMART)
			sensortag.statusCallback(statusHandler)
						.errorCallback(errorHandler)
						.keypressCallback(keypressHandler)
						.accelerometerCallback(accelerometerHandler, 100)
						.connectToNearestDevice()
		}

		function connect() { sensortag.connectToNearestDevice() }

		function disconnect()
		{
			sensortag.disconnectDevice()
			resetSensorDisplayValues()
		}

		function statusHandler(status) { displayValue('StatusData', status) }

		function errorHandler(error)
		{
			console.log('Error: ' + error)
			if (evothings.easyble.error.DISCONNECTED == error) { resetSensorDisplayValues() }
			else { displayValue('StatusData', 'Error: ' + error) }
		}

		var recording = false
		function keypressHandler(data)
		{
			// Update background color.
			if(data[0] == 1) {
				recording = !recording
				if (recording) {hyper.log("Start recording...")} 
				else {hyper.log ("Done recording...")}
			}
		}

		function resetSensorDisplayValues()
		{
			displayValue('StatusData', 'Press Connect to find a SensorTag')
			displayValue('AccelerometerData', '[Waiting for value]')
			displayValue('Result', 'Not recording')
		}

		var x_offset = -0.004
		var y_offset = 0.0
		var z_offset = -0.01
		var recordStartTime = 0.0
		var record = []
		function accelerometerHandler (data)
		{	
			if (recording) { // if it is recording 
				var values = sensortag.getAccelerometerValues(data)
				if (!isNaN (values.x) && !isNaN (values.y) && !isNaN (values.z)) {
					if (record.length == 0) {
						displayValue('Result', 'Recording')
						recordStartTime = Date.now()/1000
					}
					var x = parseFloat ((values.x - x_offset).toFixed(2))
					var y = parseFloat ((values.y - y_offset).toFixed(2))
					var z = parseFloat ((values.z - z_offset).toFixed(2))/0.26
					record.push ([x, y, z])
					string = 'x: ' + (x >= 0 ? '+' : '') + x + 'G' + 'y: ' + (y >= 0 ? '+' : '') + y + 'G' + 'z: ' + (z >= 0 ? '+' : '') + z + 'G' 
					displayValue('AccelerometerData', string)
				}
			} else {
				if(record.length != 0) {
					hyper.log ( "Duration : " + ((Date.now()/1000) - recordStartTime) + " " + record.length + "recorded" )
					getBestMatching(record)
					printReading (record)
					record = []
					displayValue('AccelerometerData', '[Waiting for value]')
				}
			}
		}
	
      var dataset = Gesture.init()
	function getBestMatching (data) {
		var result = []
		var temp = interpolate(segment(smooth(data)))
		result.push(getReadingDistance(dataset[0], temp))
		result.push(getReadingDistance(dataset[1], temp))
		result.push(getReadingDistance(dataset[2], temp))
		result.push(getReadingDistance(dataset[3], temp))
		result.push(getReadingDistance(dataset[4], temp))
		result.push(getReadingDistance(dataset[5], temp))
		result.push(getReadingDistance(dataset[6], temp))
		result.push(getReadingDistance(dataset[7], temp))
		result.push(getReadingDistance(dataset[8], temp))
		result.push(getReadingDistance(dataset[9], temp))

		var index = minIndex(result)
		if (index == 0) {
			Game.moveLeft()
		}
		if (index == 1) {
			Game.moveRight()
		}
		hyper.log(result)
		hyper.log(index)
		displayValue('Result', "Input is " + index)
		return index
	}

	function getReadingDistance (r1, r2) {
			var dis = 0.0;
			for (i = 0; i < r1.length; i++) { dis += getDistance (r1[i], r2[i]) } return dis
		}

		var segmentThreshold = 3
		function segment(reading) {
			var temp = reading.slice()
			for (i = 0; i < segmentThreshold; i++){
				temp.splice(0, 1)
				temp.splice(temp.length-1, 1)
			}
				return temp
	}

	var smoothThreshold = 0.3
	function smooth (reading) {
		var smoothReading = []
		for (i = 0; i < reading.length; i++) {
			v_x = reading[i][0]
			v_y = reading[i][1]
			v_z = reading[i][2]
			if (i == 0) {
				smoothReading.push ([v_x, v_y, v_z])
			} else {
				s_x = smoothReading[i-1][0]
				s_y = smoothReading[i-1][1]
				s_z = smoothReading[i-1][2]
				smoothReading.push ([ (s_x + smoothThreshold * (v_x - s_x)), (s_y + smoothThreshold * (v_y - s_y)), (s_z + smoothThreshold * (v_z - s_z)) ])
			}
		}
		return smoothReading
	}
	
	function getAxis (reading, axis) {
		var axis_record = []
		for (i = 0; i < reading.length; i++) { axis_record.push (reading[i][axis]) } return axis_record
	}

	// http://www.hevi.info/2012/03/interpolating-and-array-to-fit-another-size/
	var interpolateThreshold = 100
	function linearInterpolate(before, after, atPoint) { return before + (after - before) * atPoint }

	function interpolateArray(data, fitCount) {
		var newData = new Array();
		var springFactor = new Number((data.length - 1) / (fitCount - 1));
		newData[0] = data[0]; // for new allocation
		for ( var i = 1; i < fitCount - 1; i++) {
			var tmp = i * springFactor;
			var before = new Number(Math.floor(tmp)).toFixed();
			var after = new Number(Math.ceil(tmp)).toFixed();
			var atPoint = tmp - before;
			newData[i] = this.linearInterpolate(data[before], data[after], atPoint);
		}
		newData[fitCount - 1] = data[data.length - 1]; // for new allocation
		return newData;
	}

		function interpolate (reading) {
			var xnew = interpolateArray(getAxis(reading, 0), interpolateThreshold)
			var ynew = interpolateArray(getAxis(reading, 1), interpolateThreshold)
			var znew = interpolateArray(getAxis(reading, 2), interpolateThreshold )
			return assemblyReading (xnew, ynew, znew)
		}

		function assemblyReading (x, y, z) {
			var temp = []
			for (i = 0; i < x.length; i++) {
				temp[i] = [x[i], y[i], z[i]]
			}
			return temp
		}

	function getDistance (v1, v2) { return Math.sqrt (Math.pow ( (v1[0] - v2[0]), 2 ) + Math.pow ( (v1[1] - v2[1]), 2 ) + Math.pow ( (v1[2] - v2[2]), 2 )) }

	function printReading (reading) {
		var log = ""
		for (i = 0; i < reading.length; i++) {
			if ( i != reading.length -1 ) { log += "[" + reading[i] + "]" + "," } 
			else { log += "[" + reading[i] + "]" }
		}
		hyper.log (log)
	}

	function minIndex(arr) {
		if (!arr || arr.length === 0) { return -1 }
		var min = arr[0];
		var minIndex = 0;
		for (var len = arr.length; len > 0; len--) {
			if (arr[len] < min) {
				min = arr[len];
				minIndex = len;
			}
		}
		return minIndex;
	}

		function displayValue (elementId, value) { document.getElementById(elementId).innerHTML = value }

		document.addEventListener('deviceready',function() { evothings.scriptsLoaded(initialiseSensorTag) },false)
	</script>

</body>

</html>
