<!DOCTYPE html>
<!--
	Demonstration of the TI SensorTag JavaScript library.
-->
<html>

<head>
	<meta charset="utf-8" />
	<meta name="format-detection" content="telephone=no" />
	<meta name="viewport" content="width=device-width, user-scalable=no,
		shrink-to-fit=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />

	<title>TI SensorTag CC2650 &amp; CC2541 Sensors</title>

	<style>
		@import 'ui/css/evothings-app.css';
	</style>

	<script>
	// Redirect console.log to Evothings Workbench.
	if (window.hyper && window.hyper.log) { console.log = hyper.log }
	</script>
   	<script src="libs/plotly-latest.min.js"></script>
	<script src="cordova.js"></script>
	<script src="libs/evothings/evothings.js"></script>
	<script src="libs/evothings/ui/ui.js"></script>
	<script src="libs/evothings/tisensortag/tisensortag.js"></script>
</head>

<body>

	<header>
		<button class="back" onclick="history.back()">
			<img src="ui/images/arrow-left.svg" />
		</button>
		<img class="logotype" src="ui/images/logo.svg" alt="Evothings" />
		<!--<button class="menu" onclick=""><img src="ui/images/menu.svg" /></button>-->
	</header>

	<p id="upgradeNotice" class="hidden">
		<span class="color_softred">Please upgrade the firmware of your SensorTag.</span>
	</p>

	<button onclick="connect()" class="green">
		connect
	</button>

	<button onclick="disconnect()" class="charcoal">
		disconnect
	</button>

	<button onclick="train()" class="charcoal">
		train
	</button>

	<button onclick="test()" class="charcoal">
		test
	</button>


	<p>
		<strong>Status:</strong> <span id="StatusData">Press Connect to find the nearest SensorTag</span>
	</p>

	<h2>Accelerometer:</h2>
	<p>
		<span id="AccelerometerData">[Waiting for value]</span>
	</p>

	<h2>Device info:</h2>
	<p>
		SensorTag device model: <span id="DeviceModel">?</span><br />
		Firmware version: <span id="FirmwareData">?</span>
	</p>

	<div id="myDiv" style="width: 300px; height: 300px;"><!-- Plotly chart will be drawn inside this DIV --></div>

	<script>
	// SensorTag object.
	var sensortag

	function initialiseSensorTag()
	{
		// Create SensorTag CC2650 instance.
		sensortag = evothings.tisensortag.createInstance(
			evothings.tisensortag.CC2650_BLUETOOTH_SMART)

		sensortag
			.statusCallback(statusHandler)
			.errorCallback(errorHandler)
			.accelerometerCallback(accelerometerHandler, 100)
	}

	function connect()
	{
		sensortag.connectToNearestDevice()
	}

	function disconnect()
	{
		sensortag.disconnectDevice()
		resetSensorDisplayValues()
	}

	var sensorsOn = true


	function statusHandler(status)
	{
		if ('DEVICE_INFO_AVAILABLE' == status)
		{
			var upgradeNotice = document.getElementById('upgradeNotice')
			if ('CC2541' == sensortag.getDeviceModel() &&
				parseFloat(sensortag.getFirmwareString()) < 1.5)
			{
				upgradeNotice.classList.remove('hidden')
			}
			else
			{
				upgradeNotice.classList.add('hidden')
			}

			// Show device model and firmware version.
			displayValue('DeviceModel', sensortag.getDeviceModel())
			displayValue('FirmwareData', sensortag.getFirmwareString())

			// Show which sensors are not supported by the connected SensorTag.
			if (!sensortag.isLuxometerAvailable())
			{
				document.getElementById('Luxometer').style.display = 'none'
			}
		}

		displayValue('StatusData', status)
	}

	function errorHandler(error)
	{
		console.log('Error: ' + error)

		if (evothings.easyble.error.DISCONNECTED == error)
		{
			resetSensorDisplayValues()
		}
		else
		{
			displayValue('StatusData', 'Error: ' + error)
		}
	}

	function resetSensorDisplayValues()
	{
		// Clear current values.
		var blank = '[Waiting for value]'
		displayValue('StatusData', 'Press Connect to find a SensorTag')
		displayValue('DeviceModel', '?')
		displayValue('FirmwareData', '?')
		displayValue('AccelerometerData', blank)
		// Reset screen color.
	}
	var updateUpperBound = 0.3
	var updateLowerBound = 0.025

	var x_offset = -0.004
	var y_offset = 0.005
	var z_offset = -0.01

	var x_prev = 0
	var y_prev = 0
	var z_prev = 0	

	var x_record = []
	var y_record = []
	var z_record = []

	var recordStartTime = 0.0
	var recording = false
	var record = []
	
	var testData = [[-0.0479,-0.0201,0.1498],[-0.1176,-0.0176,0.638],[-0.2567,-0.144,1.1717],[-0.3317,-0.0093,1.5227],[-0.3042,0.0326,1.277],[-0.2466,0.006,1.0434],[-0.2226,-0.0172,0.7738],[-0.2306,-0.0432,0.5389],[-0.238,0.0549,0.4769],[-0.2854,0.1255,0.5083],[-0.3018,0.0521,0.4315],[-0.2264,-0.0594,0.3578],[-0.1366,-0.1212,0.4639],[-0.1441,-0.0248,0.723],[-0.1632,-0.0049,1.4527],[-0.1979,0.0456,1.4315],[-0.1679,0.0123,1.2701],[-0.1446,0.0225,1.0825],[-0.0407,0.0107,0.4014],[0.0703,0.0603,-0.1036],[0.0981,0.0404,0.4659],[0.1183,-0.0548,1.153],[0.0871,-0.1007,1.158],[0.075,-0.1063,0.932],[-0.0139,-0.0666,0.9278],[-0.107,0.0813,0.9873],[-0.0507,0.2318,0.8137],[-0.0381,0.2163,0.8618],[-0.0161,0.1638,0.8794],[0.0085,0.1086,0.9034]]
	
	function accelerometerHandler (data)
	{	
		var values = sensortag.getAccelerometerValues(data)
		if (!isNaN (values.x) && !isNaN (values.y) && !isNaN (values.z)) {
			var x = parseFloat ((values.x - x_offset).toFixed(4))
			var y = parseFloat ((values.y - y_offset).toFixed(4))
			var z = parseFloat (((values.z - z_offset)/-0.245).toFixed(4))
		
			// Prepare the information to display.
			string =	'x: ' + (x >= 0 ? '+' : '') + x + 'G<br/>' +
						'y: ' + (y >= 0 ? '+' : '') + y + 'G<br/>' +
						'z: ' + (z >= 0 ? '+' : '') + z + 'G<br/>' 

			// Update the value displayed.
			displayValue('AccelerometerData', string)
			var distance = Math.sqrt (Math.pow ((x - x_prev), 2) + Math.pow ((y - y_prev), 2) + Math.pow ((z - z_prev), 2))
            if ( distance > updateUpperBound) { recording = true }
            if ( distance < updateLowerBound) { recording = false }
            if (recording) {
                if (record.length == 0) {
                    hyper.log ("Recording start")
                    recordStartTime = Date.now()/1000
                }
                record.push ([x, y, z])
			} else {
				if (record.length != 0) {
					hyper.log ( "Duration : " + ((Date.now()/1000) - recordStartTime) + "\n")
					printReading (record)
					record = []	
					refreshPrevs ()
					//for recognision
					if (record.length > 5) { recognise (record) } 
					else { hyper.log ("try again") }
				}
            }
			updatePrevs (x, y, z)
		}
	}

	var medoidsArray = []
	var PIs = []
	var As = []
	var Bs = []
	var averageProbArray = []
	var N = 4
	var M = 8
	var gestureBaseSize = 1
	var trainingInteration = 100
	
	var data_square = [[-0.0533,-0.007,0.1747],[-0.1667,0.007,1.0498],[-0.2906,0.0154,1.3326],[-0.3609,0.023,1.4748],[-0.2745,0.1095,1.3495],[-0.1976,0.0772,0.7412],[-0.2501,0.0725,0.4796],[-0.2678,0.0635,0.3648],[-0.2896,0.0751,0.3996],[-0.2729,0.0443,0.3847],[-0.2315,-0.0234,0.586],[-0.1679,-0.0664,0.6081],[-0.1481,0.0064,0.7778],[-0.1519,0.0775,1.1268],[-0.1664,0.108,1.3715],[-0.1424,0.0873,1.3184],[-0.1154,0.086,1.1273],[-0.0469,0.0301,0.7215],[0.0655,-0.004,-0.0094],[0.1481,0.0713,0.1348],[0.142,0.0634,0.7701],[0.1253,-0.0134,0.9928],[0.1061,-0.0784,0.9188],[0.0762,-0.1164,0.9612],[0.0252,0.023,1.0553],[-0.0064,0.1054,0.9592],[-0.0447,0.2341,0.9143],[-0.0224,0.2949,0.8735],[0.0216,0.1661,0.7733],[0.05,0.1275,0.8169],[0.0733,0.1,0.7903]]
	var data_triangle = [[0.0087,-0.1016,0.7342],[-0.1001,-0.0938,1.0065],[-0.2204,-0.0469,1.438],[-0.2531,0.0347,1.5551],[-0.1945,0.1454,1.2188],[-0.105,0.0867,0.8628],[-0.1215,0.0419,0.7721],[-0.1588,0.0454,0.6587],[-0.1934,0.0018,0.6196],[-0.2403,-0.0694,0.6625],[-0.2706,-0.0413,0.7474],[-0.2871,-0.0414,0.7213],[-0.2466,-0.0974,0.6298],[-0.1583,-0.1225,0.7389],[-0.1302,-0.0495,0.938],[-0.135,-0.0283,1.1027],[-0.151,-0.0621,1.2252],[-0.17,0.0034,1.3872],[-0.1641,0.0223,1.2476],[-0.1253,0.0796,1.1111],[-0.0767,0.0757,0.9769],[-0.0104,0.1347,0.0362],[0.1006,0.1341,-0.1778],[0.149,0.1333,0.0638],[0.1646,0.131,0.3837],[0.1648,0.1162,0.5167],[0.1705,0.1435,0.5504],[0.1627,0.1404,0.4918]]
	var data_circle = [[0.1556,0.0992,0.5675],[0.1007,0.1301,1.0618],[0.0576,0.1092,1.144],[0.0314,0.1078,1.1702],[0.0086,0.0853,1.0449],[0.0617,-0.0037,0.6649],[-0.0352,0.0671,1.0087],[-0.0111,0.0491,0.9193],[-0.037,0.0564,0.9676],[-0.0902,0.0099,0.8563],[-0.0684,0.044,0.93],[-0.063,0.0962,1.0364],[-0.1067,0.0163,1.0481],[-0.068,-0.0024,0.8675],[-0.0504,-0.0147,0.7656],[-0.0943,-0.0453,0.6592],[-0.1131,-0.098,0.3379],[-0.1862,-0.1721,0.3797],[-0.2605,-0.1565,0.6114],[-0.2161,-0.1574,-0.0378],[-0.1045,-0.1426,-0.3532],[-0.2539,-0.1226,0.2925],[-0.1672,-0.0615,0.1767],[-0.2248,-0.1103,0.3326],[-0.2304,-0.2224,0.4749],[-0.1611,-0.0948,0.5025],[-0.1528,-0.1395,0.4223],[-0.1641,-0.1535,0.4405]]
	var datasets = [data_square, data_triangle, data_circle]

	function recognise (reading) {
		var recogniseResult = new Array () 
		recogniseResult [0] = forward_with_scale (PIs[0], As[0], Bs[0], classify (reading, medoidsArray[0]))[0]
		recogniseResult [1] = forward_with_scale (PIs[1], As[1], Bs[1], classify (reading, medoidsArray[1]))[0]
		recogniseResult [2] = forward_with_scale (PIs[2], As[2], Bs[2], classify (reading, medoidsArray[2]))[0]
		
		var probSum = 0
		for (i = 0; i < datasets.length; i++) {
			probSum += recogniseResult[i]
		}
		for (i = 0; i < datasets.length; i++) {
			recogniseResult[i] = (recogniseResult[i] * averageProbArray[i]) / (probSum * averageProbArray[i]) 
		}
		hyper.log (recogniseResult)
		hyper.log (minIndex (recogniseResult))
	}

	function train () {
		var k_square = kmedoids (smoothData (datasets[0]), M)
		var trainingResult_square = baumwelch (k_square[0])
		medoidsArray[0] = k_square[1]
		PIs[0] = trainingResult_square[2]
		As[0] = trainingResult_square[3]
		Bs[0] = trainingResult_square[4]
		averageProbArray[0] = trainingResult_square[5]

		var k_triangle= kmedoids (smoothData (datasets[1]), M)
		var trainingResult_triangle = baumwelch (k_triangle[0])
		medoidsArray[1] = k_triangle[1]
		PIs[1] = trainingResult_triangle[2]
		As[1] = trainingResult_triangle[3]
		Bs[1] = trainingResult_triangle[4]
		averageProbArray[1] = trainingResult_triangle[5]

		var k_circle = kmedoids (smoothData (datasets[2]), M)
		var trainingResult_circle = baumwelch (k_circle[0])
		medoidsArray[2] = k_circle[1]
		PIs[2] = trainingResult_circle[2]
		As[2] = trainingResult_circle[3]
		Bs[2] = trainingResult_circle[4]
		averageProbArray[2] = trainingResult_circle[5]
	}

 	function test () {
		 train ()
		 recognise (data_square)
	 }

	var smoothThreshold = 0.3
	function smoothData (reading) {
		var smoothReading = []
		for (i = 0; i < reading.length; i++) {
			v_x = reading[i][0]
			v_y = reading[i][1]
			v_z = reading[i][2]
			if (i == 0) {
				smoothReading.push ([v_x, v_y, v_z])
			} else {
				s_x = smoothReading[i-1][0]
				s_y = smoothReading[i-1][1]
				s_z = smoothReading[i-1][2]
				smoothReading.push ([ (s_x + smoothThreshold * (v_x - s_x)), (s_y + smoothThreshold * (v_y - s_y)), (s_z + smoothThreshold * (v_z - s_z)) ])
			}
		}
		return smoothReading
	}

	var testMedoids = [[-0.22225373,-0.019978049999999994,0.9767240799999999],[0.04087080859427723,-0.027287009892885124,0.8590724814935765],[-0.0479,-0.0201,0.1498],[-0.1956816974285041,-0.027106931288326346,0.5675729346939565],[-0.026964903199559825,0.10642304324730278,0.8815369919646254]]
	function classify (reading, medoids) {
		var observation = []
		// for each reading element
		for (i = 0; i < reading.length; i++) {
			var minimumDistanceIndex = -1
			var minimumDistance = -1
			// for each medoids
			for (j = 0; j < medoids.length; j++) {
				var dis = getDistance (reading[i], medoids[j])
				if (minimumDistanceIndex == -1) {
					minimumDistanceIndex = j
					minimumDistance = dis
				} else {
					if ( dis <= minimumDistance) {
						minimumDistanceIndex = j
						minimumDistance = dis
					}							
				}					
			} // j
			observation[i] = minimumDistanceIndex
		}
		return observation
	}

	// for training
	var maxKmedoidsIteration = 10
	function kmedoids (reading, numOfCluster) {
		var observation = []
		var clusterGroup = []
		var medoids = []
	
		var temp = reading.slice()
		// init 
		for ( i = 0; i < numOfCluster; i++) {
			var random = getRandomInt (0, temp.length)
			medoids[i] = temp [random]
			temp.splice(random, 1)
		}
		
		// looping optimisation
		for (iteration = 0; iteration < maxKmedoidsIteration; iteration++) {
			// init 14 empty clusters as a group
			for (i = 0; i < numOfCluster; i++) {
				clusterGroup[i] = []
			}

			// for each reading element
			for (i = 0; i < reading.length; i++) {
				var minimumDistanceIndex = -1
				var minimumDistance = -1
				// for each medoids
				for (j = 0; j < medoids.length; j++) {
					var dis = getDistance (reading[i], medoids[j])
					if (minimumDistanceIndex == -1) {
						minimumDistanceIndex = j
						minimumDistance = dis
					} else {
						if ( dis <= minimumDistance) {
							minimumDistanceIndex = j
							minimumDistance = dis
						}							
					}					
				} // j
				observation[i] = minimumDistanceIndex
				clusterGroup [minimumDistanceIndex].push(reading[i])
			} // i
			// recompute medoids
			for (clusterIndex = 0; clusterIndex < numOfCluster; clusterIndex++) {
				var minMedoidIndex = -1
				var minMedoidDistance = -1
				var cost = 0.0
				for (n = 0; n < clusterGroup[clusterIndex].length; n++) {
					cost = 0.0
					for (m = 0; m < clusterGroup[clusterIndex].length; m++) {
						cost += getDistance (clusterGroup[clusterIndex][n], clusterGroup[clusterIndex][m])
					}
					if (minMedoidIndex == -1) {
						minMedoidIndex = n
						minMedoidDistance = cost
					} else {
						if (cost < minMedoidDistance) {
							minMedoidIndex = n
							minMedoidDistance = cost	
						}
					}
				}
				medoids[clusterIndex] = clusterGroup[clusterIndex][minMedoidIndex]
			}	// recompute medoids
		} // iteration
		return [observation, medoids]
	}

	function getDistance (v1, v2) {
		return Math.sqrt (Math.pow ( (v1[0] - v2[0]), 2 ) + Math.pow ( (v1[1] - v2[1]), 2 ) + Math.pow ( (v1[2] - v2[2]), 2 ))
	}

	function getRandomInt(min, max) {
		return Math.floor(Math.random() * (max - min)) + min;
	}

	function printReading (reading) {
		var log = ""
		for (i = 0; i < reading.length; i++) {
			if ( i != reading.length -1 ) { log += "[" + reading[i] + "]" + "," } 
			else { log += "[" + reading[i] + "]" }
		}
		hyper.log (log)
	}

	function updatePrevs (x, y, z) {
		x_prev = x
        y_prev = y
    	z_prev = z
	}

	function refreshPrevs () {
		updatePrevs (0, 0, 0)
	}

	// https://github.com/dkyang/UMDHMM-python/blob/master/hmm.py#L205
	function forward_with_scale (pi, A, B, observation) {
	
		var T = observation.length
		var alphas = zerosMatrix (N,T)
		var scales = zerosScales (T)
		// t = 0
		for (n = 0; n < N; n++) {
			alphas[n][0] = pi[n] * B[n][observation[0]]
		} 
		scales[0] = sumOfColumn (alphas, 0)
		for (n = 0; n < N; n++) {
			
			alphas[n][0] /= scales[0]
		}
		// t = 1 ~ T - 1
		for (t = 1; t < T; t++) {
			for (n = 0; n < N; n++) {
				var sumOfAlpha = 0
				for (a = 0; a < N; a++) {
					sumOfAlpha += alphas[a][t-1] * A[a][n]
				} // for sum
				alphas[n][t] = sumOfAlpha * B[n][observation[t]]
			}
			scales[t] = sumOfColumn (alphas, t)
			
			for (i = 0; i < N; i++) {
				alphas[i][t] /= scales[t]
			}
		}
		// calculate log prob
		var logprob = 0
		for (t = 0; t < T; t++) {
			logprob += Math.log(scales[t])
		}
		return [logprob, alphas, scales]
	}

	function backward_with_scale (A, B, observation, scales) {
		var T = observation.length
		var betas = zerosMatrix (N, T)
		
		// from the last one t = T-1
		for (n = 0; n < N; n++) {
			betas[n][T-1] = 1 / scales[T-1]
		} 
		
		// now loop backwards from T-1 to 1
		for (t = T-2; t >= 0; t--) {
			for (n = 0; n < N; n++) {
				var sumOfBeta = 0
				for (i = 0; i < N; i++) {
					sumOfBeta +=  A[n][i] * B[i][observation[t+1]] * betas[i][t+1]
				}
				betas[n][t] = sumOfBeta / scales[t]
			}
		}
		return betas
	}
	// http://www.shokhirev.com/nikolai/abc/alg/hmm/hmm.html
	// Expectation - Maximization approach
	function baumwelch (observation) {
		
		var T = observation.length
	
		var pi = zerosScales(N)
		var A = zerosMatrix(N, N)
		var B = zerosMatrix(N, M) 
		
		//var initPi = 1/N
		// 1.1 init pi, A, B 
		// or init it as first pi = 1 and rest = 0
		for (column = 0; column < N; column++) {
			if (column == 0) {
				pi[column] = 1
			} else {
				pi[column] = 0
			}
		}
		// Init A
		for (i = 0; i < N; i++) {
			for (j = 0; j < N; j++) {
				if (i == j) {
					A[i][j] = 1/2
				}
				if (i == j - 1) {
					A[i][j] = 1/2
				}
				if (i == N-1 && j == N-1) {
					A[i][j] = 1
				}
			}
		}

		// Init B
		for (i = 0; i < N; i++) {
			for (j = 0; j < M; j++) {
				B[i][j] = 1/M
			}
		}

		var f = forward_with_scale (pi, A, B, observation)
		var logprobprev = f[0]
		var alphas = f[1]
		var scales = f[2]
		var betas = backward_with_scale (A, B, observation, scales)
		var gamma = computeGamma (alphas, betas, T)
		var xi = computeXi(A, B, observation, alphas,betas)

		var logprobinit = logprobprev
		
		var probTemp = 0
		// interation may be a problem 16 is recommanded
		for (q = 0; q < trainingInteration; q++) {
			// 2.1 compute pi
			probTemp += logprobprev
		//	hyper.log (pi)
			for (column = 0; column < N; column++) {
		//		hyper.log (gamma[column][0])
				pi[column] = gamma[column][0];
			}
			// 2.2 compute transition matrix and emission matrix
			for (row = 0; row < N; row++) {
				var denominatorA = 0;
				for (time = 0; time < T-1; time++) {
					denominatorA += gamma[row][time];
				}
				for (column = 0; column < N; column++) {
					var numberatorA = 0;
					for (time = 0; time < T-1; time++) {
						numberatorA += xi[row][column][time]
					}
					A[row][column] = 0.0001 + 0.9999 * (numberatorA / denominatorA)
				}
			}	// A
			for (j = 0; j < N; j++) {
				var denominatorB = 0
				for (time = 0; time < T; time++) {
					denominatorB += gamma[j][time]
				}
				for (k = 0; k < M; k++) {
					numeratorB = 0.0
					for (t = 0; t < T; t++) {
						if (observation[t] == k) {
							numeratorB += gamma[j][t]
						}
					}
					B[j][k] = 0.0001 + 0.9999 * (numeratorB / denominatorB)
				}
			} // B
			f = forward_with_scale (pi, A, B, observation)
			logprobcur = f[0]
			alphas = f[1]
			scales = f[2]
			
			betas = backward_with_scale (A, B, observation, scales)
			gamma = computeGamma (alphas, betas, T)
			xi = computeXi(A, B, observation, alphas,betas)
			delta = logprobcur - logprobprev
			logprobprev = logprobcur
		} 
		logprobfinal = logprobcur
		probTemp /= trainingInteration
		return [logprobinit, logprobfinal, pi, A, B, probTemp]
	}
	// https://github.com/liwenzhu/nodehmm/blob/master/lib/baum.js#L21		
	// compute γ
	function computeGamma (alphas, betas, T) {
		
			var gamma = zerosMatrix(N, T)
			for (t = 0; t < T; t++) {
				denominator = 0
				for (n = 0; n < N; n++) {
					gamma[n][t] = alphas[n][t] * betas[n][t];
					denominator +=  gamma[n][t];
				}
				for (n = 0; n < N; n++) {
					gamma[n][t] = gamma[n][t] / denominator;
				}
			}
		return gamma
	}
	// compute ξ
	function computeXi (A, B, observation, alphas, betas) {
		
		var xi = [];
		var T = observation.length;
		
		// init xi[i][j][t]
		var columnI, columnJ, time, sum;
		for (columnI = 0; columnI < N; columnI++) {
			xi[columnI] = [];
			for(columnJ = 0; columnJ < N; columnJ++) {
				xi[columnI][columnJ] = [];
				for (time = 0; time < T; time++) {
					xi[columnI][columnJ][time] = [];
				}
			}
		}
		
		for (time = 0; time < T - 1; time++) {
			sum = 0;
			for (columnI = 0; columnI < N; columnI++) {
				for (columnJ = 0; columnJ < N; columnJ++) {
				
					xi[columnI][columnJ][time] = alphas[columnI][time] 
												* A[columnI][columnJ] 
												* betas[columnJ][time+1]
												* B[columnJ][observation[time+1]];
											
					sum += xi[columnI][columnJ][time];
				}
			}
			for (columnI = 0; columnI < N; columnI++) {
				for (columnJ = 0; columnJ < N; columnJ++) {
					xi[columnI][columnJ][time] = xi[columnI][columnJ][time] / sum;
				}
			}
		}
		return xi
	}
	function printMatrix (matrix) {
		var temp = ""
		
		for( i = 0; i < matrix.length; i++) {
			for( j = 0; j < matrix[i].length; j++) {
				if (j!=matrix[i].length-1) {
					temp = temp + matrix[i][j] + "," 
				} else {
					temp = temp + matrix[i][j]
				}
			} 
			hyper.log(temp) 
			temp = ""
		}
	}
	
	function zerosMatrix (row, column) {
		var matrix = new Array (row)
		for (i = 0; i < row; i++) {
			matrix[i] = new Array (column)
		}
		for (i = 0; i < row; i++) {
			for (j = 0; j < column; j++) {
				matrix [i][j] = 0
			}
		}
		return matrix
	}
	function zerosScales (length) {
		var scales = new Array (length)
		for (i = 0; i < length; i++) {
			scales[i] = 0
		}
		return scales
	}
	function sumOfColumn (matrix, column) {
		var sum = 0
		for (i = 0; i < matrix.length; i++) {
			sum += matrix[i][column]
		}
		return sum
	}
	function getRandomInt(min, max) {
		return Math.floor(Math.random() * (max - min)) + min;
	}

	function minIndex(arr) {
		if (!arr || arr.length === 0) {
			return -1;
		}
		var min = arr[0];
		var minIndex = 0;
		for (var len = arr.length; len > 0; len--) {
			if (arr[len] < min) {
				min = arr[len];
				minIndex = len;
			}
		}
		return minIndex;
	}

	function displayValue (elementId, value)
	{
		document.getElementById(elementId).innerHTML = value
	}

	document.addEventListener(
		'deviceready',
		function() { evothings.scriptsLoaded(initialiseSensorTag) },
		false)
	</script>

</body>

</html>
