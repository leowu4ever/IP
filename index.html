<!DOCTYPE html>

<html>
<head>
	<meta charset="utf-8" />
	<meta name="format-detection" content="telephone=no" />
	<meta name="viewport" content="width=device-width, user-scalable=no,
		shrink-to-fit=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />

	<title>TI SensorTag CC2650 &amp; CC2541 Sensors</title>

	<style>
		@import 'ui/css/evothings-app.css';
	</style>

	<script>
	// Redirect console.log to Evothings Workbench.	
		if (window.hyper && window.hyper.log) { console.log = hyper.log}
	</script>
   	
	<script type="text/javascript" src="libs/jscharts.js"></script>
    <script src="libs/crafty.js"></script>
	<script src="cordova.js"></script>
	<script src="libs/evothings/evothings.js"></script>
	<script src="libs/evothings/ui/ui.js"></script>
	<script src="libs/evothings/tisensortag/tisensortag.js"></script>
</head>

<body>
	<button onclick="connect()" class="green">Connect</button>
	<button onclick="disconnect()" class="yellow">Disconnect</button>
	<button onclick="train()" class="blue">Train</button>
	<p>
		<strong>Status:</strong> 
		<span id="StatusData">Press Connect to find the nearest SensorTag</span>
	</p>

	<h2>Accelerometer:</h2>
	<p>
		<span id="AccelerometerData">[Waiting for value]</span>
	</p>
	
	<div id="game"></div>

	<script>
		var sensortag

		function initialiseSensorTag()
		{
			// Create SensorTa	g CC2650 instance.
			sensortag = evothings.tisensortag.createInstance(evothings.tisensortag.CC2650_BLUETOOTH_SMART)
			sensortag.statusCallback(statusHandler)
					 .errorCallback(errorHandler)
				     .accelerometerCallback(accelerometerHandler, 100)
		}

		function connect()
		{
			//startGame()
			sensortag.connectToNearestDevice()
		}

		function disconnect()
		{
			sensortag.disconnectDevice()
			resetSensorDisplayValues()
		}
		
		function statusHandler(status)
		{
			displayValue('StatusData', status)
		}

		function errorHandler(error)
		{
			console.log('Error: ' + error)

			if (evothings.easyble.error.DISCONNECTED == error)
			{
				resetSensorDisplayValues()
			}
			else
			{
				displayValue('StatusData', 'Error: ' + error)
			}
		}

		function resetSensorDisplayValues()
		{
			var blank = '[Waiting for value]'
			displayValue('StatusData', 'Press Connect to find a SensorTag')
			displayValue('AccelerometerData', blank)
		}
		
		function displayValue(elementId, value)
		{
			document.getElementById(elementId).innerHTML = value
		}
		
		document.addEventListener(
			'deviceready',
			function() { evothings.scriptsLoaded(initialiseSensorTag) },
			false)	

		// ------------------------------------------ Sensor Reading ------------------------------------------
		var string = ""
		var updateUpperBound = 0.4	
		var updateLowerBound = 0.1

		var x_offset = -0.01
		var y_offset = 0
		var z_offset = -0.01	
		
		var xPrev = 0
		var yPrev = 0
		var zPrev = 0

		var record = ""
		var recording = false

		function accelerometerHandler(data)
		{
			var values = sensortag.getAccelerometerValues(data)
			if (!isNaN(values.x) && !isNaN(values.y) && !isNaN(values.z)) {
				
				var x = parseFloat((values.x - x_offset).toFixed(2))
				var y = parseFloat((values.y - y_offset).toFixed(2))
				var z = parseFloat((values.z - z_offset).toFixed(2))/-0.25 
				
				string = 'X ' + (x >= 0 ? '+' : '') + x + 'G</br>' +
							'Y ' + (y >= 0 ? '+' : '') + y + 'G</br>' +
							'Z ' + (z >= 0 ? '+' : '') + z + 'G</br>' 
				displayValue('AccelerometerData', string)	
						
				if (Math.sqrt (Math.pow ((x - xPrev), 2) + Math.pow ((y - yPrev), 2) + Math.pow ((z - zPrev), 2)) > updateUpperBound) {
					recording = true
				} 

				if (Math.sqrt (Math.pow ((x - xPrev), 2) + Math.pow ((y - yPrev), 2) + Math.pow ((z - zPrev), 2)) < updateLowerBound) {
					recording = false
				} 

				if (recording) {
					 record += x + "," + y + "," + z + "|"
					 hyper.log ("moving")
				} else {
 					if (record != "") {
						hyper.log(record)
						record = ""
					}
				}

				xPrev = x
				yPrev = y
				zPrev = z
			}
		}
				
		// ------------------------------------------ HMM ------------------------------------------
		N = 8
		M = 14
		trainingData = [[0.01,-0.16,-0.84],[0,-0.17,-0.84],[-0.01,-0.16,-0.84],[-0.02,-0.16,-0.8],[-0.04,-0.18,-0.76],[0,-0.16,-0.68],[0.01,-0.16,-0.76],[0.01,-0.17,-0.76],[0.01,-0.17,-0.76],[0,-0.19,-0.8],[-0.02,-0.21,-0.72],[-0.01,-0.21,-0.68],[0.01,-0.2,-0.68],[0.03,-0.2,-0.76],[0.06,-0.18,-0.88],[0.06,-0.17,-0.88],[0.05,-0.18,-0.72],[0.06,-0.22,-0.8],[0.01,-0.25,-0.84],[-0.04,-0.24,-0.84],[-0.08,-0.21,-0.76],[-0.1,-0.18,-0.84],[-0.12,-0.15,-0.8],[-0.14,-0.14,-0.64],[-0.12,-0.08,-0.72],[-0.11,-0.06,-0.72],[-0.1,-0.05,-0.76],[-0.04,-0.01,-0.68],[0.02,0,-0.8],[0.04,0,-0.88],[0.03,-0.02,-0.96],[0.01,-0.05,-0.96],[-0.03,-0.08,-1.12],[-0.05,-0.08,-1.12],[-0.06,-0.1,-1.12],[-0.06,-0.11,-1],[-0.06,-0.11,-0.88],[-0.06,-0.1,-0.88],[-0.06,-0.1,-0.92]]
	
		var filterThreshold = 0.2
	
		function train () {
			// denoise reading 
			// convert to observation
			// run baum welch with the observation - and output the model and save
			var temp = denoise (trainingData)
			temp = kmeans(temp, M)
			var result = baumwelch (temp)
		} 
		
		function recognise () {
			// denoise raw reading 
			// convert to observation
			// run either forward or backward against all models - the result should be the same
			// pick the one haing the highest prob
		}

		// get rid of uncontributed inputs
		function denoise (reading) {
			
			for (i = 0; i<reading.length; i++) {
				if (i != 0) {
					if (Math.sqrt (Math.pow (reading[i][0] - reading[i-1][0], 2) +
								   Math.pow (reading[i][1] - reading[i-1][1], 2) +
								   Math.pow (reading[i][2] - reading[i-1][2], 2)) < filterThreshold ) {
									   
									   reading.splice (i,1)
								   }
				} else {
					if (Math.sqrt (Math.pow (reading[i][0] - 0, 2) +
								   Math.pow (reading[i][1] - 0, 2) +
								   Math.pow (reading[i][2] - 0, 2)) < filterThreshold ) {
									   
									   reading.splice (i,1)
								   }
				}	
			}
			// double checks
			return reading
		}
		
		var numOfKmeansIteration = 10
		
		// convert the raw data to symbolised observations
		// for baum welch, forward and backward
		
		function kmeans( reading, numOfClusters ) {
			
			var observation = new Array ()
			var clustersGroup = new Array()
			var centroids = new Array()
			
			// init 14 empty clusters group
			for ( i = 0; i < numOfClusters; i++) {
				clustersGroup[i] = new Array()
			}
			
			// first choose centroids by even distance
			jumpOfCentroids = Math.round ( reading.length / (numOfClusters+1) );
			for ( i = 0; i < numOfClusters; i++) {
				centroids[i] = reading [ (i+1) * jumpOfCentroids ]
			}
	
			for ( iteration = 0; iteration < numOfKmeansIteration; iteration++) {
				
				// init each cluster 
				for ( i = 0; i < clustersGroup.length; i++ ) {
					
					clustersGroup[i] = []
				}
				
				// actual comparison
				// each element compare with each centroid
				for ( i = 0; i < reading.length; i++) {	// for elemnent
					
					var minimumDistanceIndex = -1
					var minimumDistance = -1
					
					for ( j = 0; j < centroids.length; j++ ) {	// each centroid
						
						var dis = Math.sqrt ( Math.pow ( (reading [i][0] - centroids [j][0]), 2 ) +
											  Math.pow ( (reading [i][1] - centroids [j][1]), 2 ) +
											  Math.pow ( (reading [i][2] - centroids [j][2]), 2 ))
					
						if (minimumDistanceIndex == -1) {
							minimumDistanceIndex = j
							minimumDistance = dis
						} else {
							if ( dis <= minimumDistance) {
								minimumDistanceIndex = j
								minimumDistance = dis
							}							
						}
					}
					// put the element in the clusters group
					observation[i] = minimumDistanceIndex
					
					clustersGroup [minimumDistanceIndex].push(reading[i])
				}	
				
				// recalculate centroids
				for (i = 0; i < numOfClusters; i++) {
					var total = [0, 0, 0]
					for ( j = 0; j < clustersGroup[i].length; j++ ){
						total[0] += clustersGroup[i][j][0]
						total[1] += clustersGroup[i][j][1]
						total[2] += clustersGroup[i][j][2]
					}
				
					total[0] = total[0] / clustersGroup[i].length
					total[1] = total[1] / clustersGroup[i].length
					total[2] = total[2] / clustersGroup[i].length
					
					centroids[i] = [ total[0], total[1], total[2] ]
				}
			}
			hyper.log (observation.length)
			return observation
		}
		
		// https://github.com/dkyang/UMDHMM-python/blob/master/hmm.py#L205
		function forward_with_scale (pi, A, B, observation) {
		
			var T = observation.length

			var alphas = zerosMatrix (N,T)
			var scales = zerosScales (T)

			// t = 0
			for (n = 0; n < N; n++) {
				alphas[n][0] = pi[n] * B[n][observation[0]]
			} 

			scales[0] = sumOfColumn (alphas, 0)
			for (n = 0; n < N; n++) {
				alphas[n][0] /= scales[0]

			}
			// t = 1 ~ T - 1
			for (t = 1; t < T; t++) {
				for (n = 0; n < N; n++) {
					var sumOfAlpha = 0
					for (a = 0; a < N; a++) {
						sumOfAlpha += alphas[a][t-1] * A[a][n]
					} // for sum
					alphas[n][t] = sumOfAlpha * B[n][observation[t]]

				}
				scales[t] = sumOfColumn (alphas, t)
				
				for (i = 0; i < N; i++) {
					alphas[i][t] /= scales[t]
				}
			}

			// calculate log prob
			var logprob = 0
			for (t = 0; t < T; t++) {
				logprob += Math.log(scales[t])
			}

			return [logprob, alphas, scales]
		}
	
		function backward_with_scale (A, B, observation, scales) {
			var T = observation.length
			
			var betas = zerosMatrix (N, T)
			
			// from the last one t = T-1
			for (n = 0; n < N; n++) {
				betas[n][T-1] = 1 / scales[T-1]
			} 
			
			// now loop backwards from T-1 to 1
			for (t = T-2; t >= 0; t--) {
				for (n = 0; n < N; n++) {
					var sumOfBeta = 0
					for (i = 0; i < N; i++) {
						sumOfBeta +=  A[n][i] * B[i][observation[t+1]] * betas[i][t+1]
					}
					betas[n][t] = sumOfBeta / scales[t]
				}
			}
			return betas
		}
		
		DELTA = 0.001

		// http://www.shokhirev.com/nikolai/abc/alg/hmm/hmm.html
		// Expectation - Maximization approach
		function baumwelch (observation) {
			
			var T = observation.length
		
			var pi = zerosScales(T)
			var A = zerosMatrix(N, N)
			var B = zerosMatrix(N, M) 
			var initPi = 1/N

			// 1.1 init pi, A, B
			for (column = 0; column < N; column++) {
				pi[column] = initPi
			}
			for (i = 0; i < N; i++) {
				for (j = 0; j < N; j++) {
					if (i == j) {
						A[i][j] = 1 - 1/(T/N)
					}
					if (i == j - 1) {
						A[i][j] = 1/(T/N)
					} 
				}
			}
			for (i = 0; i < N; i++) {
				for (j = 0; j < M; j++) {
					B[i][j] = 1/M
				}
			}
	
			var f = forward_with_scale (pi, A, B, observation)
			var logprobprev = f[0]
			var alphas = f[1]
			var scales = f[2]

			var betas = backward_with_scale (A, B, observation, scales)
			var gamma = computeGamma (alphas, betas, T)
			var xi = computeXi(A, B, observation, alphas,betas)
		
			var logprobinit = logprobprev
			

			while (true) {
				// 2.1 compute pi
				for (column = 0; column < N; column++) {
					pi[column] = 0.001 + 0.999*gamma[column][0];
				}

				// 2.2 compute transition matrix and emission matrix
				for (row = 0; row < N; row++) {
					var denominatorA = 0;
					for (time = 0; time < T-1; time++) {
						denominatorA += gamma[row][time];
					}

					for (column = 0; column < N; column++) {
						var numberatorA = 0;
						for (time = 0; time < T-1; time++) {
							numberatorA += xi[row][column][time]
						}
						A[row][column] = 0.001 + 0.999 * (numberatorA / denominatorA)
					}
				}	// A

				for (j = 0; j < N; j++) {
					var denominatorB = 0
					for (time = 0; time < T; time++) {
						denominatorB += gamma[j][time]
					}

					for (k = 0; k < M; k++) {
						numeratorB = 0.0
						for (t = 0; t < T; t++) {
							if (observation[t] == k) {
								numeratorB += gamma[j][t]
							}
						}
						B[j][k] = 0.001 + 0.999 * (numeratorB / denominatorB)
					}
				} // B

				f = forward_with_scale (pi, A, B, observation)
				logprobcur = f[0]
				alphas = f[1]
				scales = f[2]
				
				betas = backward_with_scale (A, B, observation, scales)
				gamma = computeGamma (alphas, betas, T)
				xi = computeXi(A, B, observation, alphas,betas)

				delta = logprobcur - logprobprev
				logprobprev = logprobcur
			
				if (delta <= DELTA) {
					break
				}
			} // while 

			logprobfinal = logprobcur
			
			return [logprobinit, logprobfinal, pi, A, B]
		}

		// https://github.com/liwenzhu/nodehmm/blob/master/lib/baum.js#L21		
		// compute γ
		function computeGamma (alphas, betas, T) {
			
				var gamma = zerosMatrix(N, T)

				for (n = 0; n < N; n++) {
					denominator = 0;
					for (t = 0; t < T; t++) {
						gamma[n][t] = alphas[n][t] * betas[n][t];
						denominator +=  gamma[n][t];
					}

					for (t = 0; t < T; t++) {
						gamma[n][t] = gamma[n][t] / denominator;
					}
				}
				return gamma;
		}

		// compute ξ
		function computeXi (A, B, observation, alphas, betas) {
			
			var xi = [];
			var T = observation.length;
			
			// init xi[i][j][t]
			var columnI, columnJ, time, sum;
			for (columnI = 0; columnI < N; columnI++) {
				xi[columnI] = [];
				for(columnJ = 0; columnJ < N; columnJ++) {
					xi[columnI][columnJ] = [];
					for (time = 0; time < T; time++) {
						xi[columnI][columnJ][time] = [];
					}
				}
			}
			
			for (time = 0; time < T - 1; time++) {
				sum = 0;
				for (columnI = 0; columnI < N; columnI++) {
					for (columnJ = 0; columnJ < N; columnJ++) {
					
						xi[columnI][columnJ][time] = alphas[columnI][time] 
												   * A[columnI][columnJ] 
												   * betas[columnJ][time+1]
												   * B[columnJ][observation[time+1]];
												
						sum += xi[columnI][columnJ][time];
					}
				}

				for (columnI = 0; columnI < N; columnI++) {
					for (columnJ = 0; columnJ < N; columnJ++) {
						xi[columnI][columnJ][time] = xi[columnI][columnJ][time] / sum;
					}
				}
			}
			return xi
		}

		function printMatrix (matrix) {
			var temp = ""
			
			for( i = 0; i < matrix.length; i++) {
				for( j = 0; j < matrix[i].length; j++) {
					if (j!=matrix[i].length-1) {
						temp = temp + matrix[i][j] + "," 
					} else {
						temp = temp + matrix[i][j]
					}
				}
				if (i!=matrix.length-1) {
					temp = temp + '|'
				}
			}
			hyper.log(temp) 
		}
		
		function zerosMatrix (row, column) {
			var matrix = new Array (row)
			for (i = 0; i < row; i++) {
				matrix[i] = new Array (column)
			}

			for (i = 0; i < row; i++) {
				for (j = 0; j < column; j++) {
					matrix [i][j] = 0
				}
			}
			return matrix
		}

		function zerosScales (length) {
			var scales = new Array (length)
			for (i = 0; i < length; i++) {
				scales[i] = 0
			}
			return scales
		}

		function sumOfColumn (matrix, column) {
			var sum = 0
			for (i = 0; i < matrix.length; i++) {
				sum += matrix[i][column]
			}
			return sum
		}

		// ------------------------------------------ game ------------------------------------------
		var background
		var fish
		var score
		var speed = 10
		
		function startGame () {
			Crafty.init(Crafty.viewport.width, Crafty.viewport.height, document.getElementById('game'))
			
			background = Crafty.background('#FFFFFF url(Graphics/ocean.png) repeat center center')
			fish = Crafty.e("2D, DOM, Image").image("Graphics/fish.png").origin("center")
			score = Crafty.e("2D, DOM, Text").attr({x:100, y: 10}).text("score text")
			//Crafty.e("2D, DOM, Image").image("Graphics/number_one.png").origin("center")
		}	
	</script>
</body>
</html>
