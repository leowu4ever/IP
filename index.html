<!DOCTYPE html>

<html>
<head>
	<meta charset="utf-8" />
	<meta name="format-detection" content="telephone=no" />
	<meta name="viewport" content="width=device-width, user-scalable=no,
		shrink-to-fit=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />

	<title>TI SensorTag CC2650 &amp; CC2541 Sensors</title>

	<style>
		@import 'ui/css/evothings-app.css';
	</style>

	<script>
	// Redirect console.log to Evothings Workbench.	
		if (window.hyper && window.hyper.log) { console.log = hyper.log}
	</script>
   	
	<script type="text/javascript" src="libs/jscharts.js"></script>
    <script src="libs/crafty.js"></script>
	<script src="cordova.js"></script>
	<script src="libs/evothings/evothings.js"></script>
	<script src="libs/evothings/ui/ui.js"></script>
	<script src="libs/evothings/tisensortag/tisensortag.js"></script>
</head>

<body>
	<button onclick="connect()" class="green">Connect</button>
	<button onclick="disconnect()" class="yellow">Disconnect</button>
	<button onclick="startReading()" class="green">Start Reading</button>
	<button onclick="stopReading()" class="red">End Reading</button>
	<button onclick="preprocess()" class="blue">Preprocess</button>
	<button onclick="printHmm()" class="blue">PrintHmm</button>
	<p>
		<strong>Status:</strong> 
		<span id="StatusData">Press Connect to find the nearest SensorTag</span>
	</p>

	<h2>Accelerometer:</h2>
	<p>
		<span id="AccelerometerData">[Waiting for value]</span>
	</p>
	
	<div id="game"></div>

	<script>
		var sensortag
		var isReading
		var record
		
		function startReading() 
		{
			isReading = true	
		}
		
		function stopReading() 
		{
			isReading = false
			hyper.log(record)
			record = ""
		}
		
		function initialiseSensorTag()
		{
			// Create SensorTa	g CC2650 instance.
			sensortag = evothings.tisensortag.createInstance(evothings.tisensortag.CC2650_BLUETOOTH_SMART)

			sensortag
				.statusCallback(statusHandler)
				.errorCallback(errorHandler)
				.accelerometerCallback(accelerometerHandler, 100)
		}

		function connect()
		{
			//startGame()
			sensortag.connectToNearestDevice()
		}

		function disconnect()
		{
			sensortag.disconnectDevice()
			resetSensorDisplayValues()
		}
		
		function statusHandler(status)
		{
			displayValue('StatusData', status)
		}

		function errorHandler(error)
		{
			console.log('Error: ' + error)

			if (evothings.easyble.error.DISCONNECTED == error)
			{
				resetSensorDisplayValues()
			}
			else
			{
				displayValue('StatusData', 'Error: ' + error)
			}
		}

		function resetSensorDisplayValues()
		{
			var blank = '[Waiting for value]'
			displayValue('StatusData', 'Press Connect to find a SensorTag')
			displayValue('AccelerometerData', blank)
		}
		
		function displayValue(elementId, value)
		{
			document.getElementById(elementId).innerHTML = value
		}
		
		document.addEventListener(
			'deviceready',
			function() { evothings.scriptsLoaded(initialiseSensorTag) },
			false)	

		var x_offset = -0.01
		var y_offset = 0.01
		var z_offset = -0.01	
		var string = ""
		// get rid of noise first so the reading are stable 
		// next set offsets 
		
		function accelerometerHandler(data)
		{
			if (isReading) {
				var values = sensortag.getAccelerometerValues(data)
				if (!isNaN(values.x) && !isNaN(values.y) && !isNaN(values.z)) {
					
					var x = parseFloat((values.x - x_offset).toFixed(2))
					var y = parseFloat((values.y - y_offset).toFixed(2))
					var z = parseFloat((values.z - z_offset).toFixed(2))/-0.25 
					var pitch = Math.atan(y/Math.sqrt(Math.pow(x,2) + Math.pow(z,2))) * (180.0/Math.PI)
					var roll = Math.atan(x/Math.sqrt(Math.pow(y,2) + Math.pow(z,2))) * (180.0/Math.PI)
					
					record =  roll + "," + record	
					string = 'X ' + (x >= 0 ? '+' : '') + x + 'G</br>' +
							 'Y ' + (y >= 0 ? '+' : '') + y + 'G</br>' +
						     'Z ' + (z >= 0 ? '+' : '') + z + 'G</br>' +
							 'pitch : ' + pitch + '<br/>' +
 							 'roll : ' + roll + '<br/>'
						
					displayValue('AccelerometerData', string)
				}				
			}
		}
				
		// test hmm model
		N = 8
		M = 14
		trainingData = [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [1.1, 1.5, 0.6], [2.1, 1.2, 1.3], [1.4, 3.5, 0.6], [0.1, 1.2, 2.3], [1.4, 0.5, 1.6], [1.1, 3.2, 2.3], [1.4, 1.5, 1.6], [2.1, 2.2, 2.3], [3.4, 3.5, 3.6], [1.1, -0.2, 0.3], [-0.4, -0.5, -0.6], [-0.1, -0.2, 0.3], [-0.4, -0.5, -0.6]]
		
		var filterThreshold = 0.2
		
		function preprocess () {
			baumwelch(trainingData)
		}
		
		// get rid of uncontributed inputs
		function denoise (reading) {
			
			hyper.log ("trainingdata length before: " + trainingData.length)
			for (i = 0; i<reading.length; i++) {
				if (i != 0) {
					if (Math.sqrt (Math.pow (reading[i][0] - reading[i-1][0], 2) +
								   Math.pow (reading[i][1] - reading[i-1][1], 2) +
								   Math.pow (reading[i][2] - reading[i-1][2], 2)) < filterThreshold ) {
									   
									   reading.splice (i,1)
								   }
				} else {
					if (Math.sqrt (Math.pow (reading[i][0] - 0, 2) +
								   Math.pow (reading[i][1] - 0, 2) +
								   Math.pow (reading[i][2] - 0, 2)) < filterThreshold ) {
									   
									   reading.splice (i,1)
								   }
				}	
			}
			// double checks
			hyper.log ("trainingdata length after: " + trainingData.length)
			printMatrix (trainingData)
		}
		
		var numOfKmeansIteration = 10
		
		// convert the raw data to symbolised observations
		// for baum welch, forward and backward
		
		function kmeans( reading, numOfClusters ) {
			
			var observation = new Array ()
			var clustersGroup = new Array()
			var centroids = new Array()
			
			// init 14 empty clusters group
			for ( i = 0; i < numOfClusters; i++) {
				clustersGroup[i] = new Array()
			}
			
			// first choose centroids by even distance
			jumpOfCentroids = Math.round ( reading.length / (numOfClusters+1) );
			for ( i = 0; i < numOfClusters; i++) {
				centroids[i] = reading [ (i+1) * jumpOfCentroids ]
			}
	
			for ( iteration = 0; iteration < numOfKmeansIteration; iteration++) {
				
				// init each cluster 
				for ( i = 0; i < clustersGroup.length; i++ ) {
					
					clustersGroup[i] = []
				}
				
				// actual comparison
				// each element compare with each centroid
				for ( i = 0; i < reading.length; i++) {	// for elemnent
					
					var minimumDistanceIndex = -1
					var minimumDistance = -1
					
					for ( j = 0; j < centroids.length; j++ ) {	// each centroid
						
						var dis = Math.sqrt ( Math.pow ( (reading [i][0] - centroids [j][0]), 2 ) +
											  Math.pow ( (reading [i][1] - centroids [j][1]), 2 ) +
											  Math.pow ( (reading [i][2] - centroids [j][2]), 2 ))
					
						if (minimumDistanceIndex == -1) {
							minimumDistanceIndex = j
							minimumDistance = dis
						} else {
							if ( dis <= minimumDistance) {
								minimumDistanceIndex = j
								minimumDistance = dis
							}							
						}
					}
					// put the element in the clusters group
					observation[i] = minimumDistanceIndex
					
					clustersGroup [minimumDistanceIndex].push(reading[i])
				}	
				
				// recalculate centroids
				for (i = 0; i < numOfClusters; i++) {
					var total = [0, 0, 0]
					for ( j = 0; j < clustersGroup[i].length; j++ ){
						total[0] += clustersGroup[i][j][0]
						total[1] += clustersGroup[i][j][1]
						total[2] += clustersGroup[i][j][2]
					}
				
					total[0] = total[0] / clustersGroup[i].length
					total[1] = total[1] / clustersGroup[i].length
					total[2] = total[2] / clustersGroup[i].length
					
					centroids[i] = [ total[0], total[1], total[2] ]
				}
			}
			hyper.log (observation.length)
			return observation
		}
		
		// for training 
		// baum welch 
		
		// https://github.com/dkyang/UMDHMM-python/blob/master/hmm.py#L205
		function forward (PI, A, B, observation) {
		
			var T = reading.length
			var alphas = new Array ()
			
			// init alpha array
			for (i = 0; i < N; i++) {
				alphas[i] = new Array()
			}
			
			// t = 0
			for (i = 0; i < N; i++) {
				alphas[i][0] = PI[i] * B[i][observation[0]]
			} 
			
			// t = 1 ~ T - 1
			for (t = 1; t < T; t++) {
				for (i = 0; i < N; i++) {
					var temp = 0
					for (j = 0; j < N; j++) {
						temp += alphas[j][t] * A[j][i]
					}
					temp = temp * B[i][observation[t]]
					alphas[i][t] = temp
				}
			}
			
			// sum all alpha together
			var prob
			for (i = 0; i < N; i++) {
				prob += alphas[i][T-1]					
			}
			return Math.log2(prob)
		}
	
		function backward (PI, A, B, observation) {
			var T = reading.length
			var betas = new Array ()
			
			// init beta array
			for (i = 0; i < N; i++) {
				betas[i] = new Array()
			}
			
			// from the last one t = T
			for (i = 0; i < N; i++) {
				betas [i][T-1] = 1
			} 
			
			// now loop backwards from T-1 to 1
			for (t = T-1; t < 0; i--) {
				for (i = 0; i < N; i++) {
					var temp = 0
					for ( j = 0; j < N; j++ ) {
						temp += B[j][observation[t+1] - 1] * A[i][j] * betas[j][t+1]
					}
				}
			}
			
			var prob
			for (i = 0; i < N; i++) {
				prob += betas[i][0]					
			}
			return Math.log2(prob)
		}
		
		// http://www.shokhirev.com/nikolai/abc/alg/hmm/hmm.html
		// Expectation - Maximization approach
		function baumwelch (reading) {
			
			var PI = new Array ()
			var A = new Array ()
			var B = new Array ()
			var T = reading.length
			var d = T/N
	
			// init PI			
			for ( i = 0; i < reading.length; i++ ) {
				if (i == 0) {
					PI [i] = 1
				} else {
					PI [i] = 0
				}
 			}
			hyper.log ("pi " + PI)
			
			// init A
			for ( i = 0; i < N; i++ ) {
				A[i] = new Array ()	
			}
			
			for ( i = 0; i < N; i++ ) {
				for ( j = 0; j < N; j++ ) {
					if (i == j) {
						A[i][j] = 1 - 1/d
					} else if (i == j - 1) {
						A[i][j] = 1/d
					} else {
						A[i][j] = 0
					}
				}
			}	
			hyper.log ("A" + A)
			
			// init B			
			for ( i = 0; i < N; i++ ) {
				B[i] = new Array ()	
			}
			
			for (i = 0; i < N; i++) {
				for ( j = 0; j < M; j++ ) {
					B[i][j] = 1/M			
				}
			}	
			hyper.log ("B" + B)
					
			// actual learing 

			var xi
			var gamma

		}
		
		function printMatrix (matrix) {
			var temp = ""
			
			for( i = 0; i < matrix.length; i++) {
				for( j = 0; j < matrix[i].length; j++) {
					if (j!=matrix[i].length-1) {
						temp = temp + matrix[i][j] + "," 
					} else {
						temp = temp + matrix[i][j]
					}
				}
				if (i!=matrix.length-1) {
					temp = temp + '|'
				}
			}
			hyper.log(temp) 
		}
		
		

		// game	
		var background
		var fish
		var score
		var speed = 10
		
		function startGame () {
			Crafty.init(Crafty.viewport.width, Crafty.viewport.height, document.getElementById('game'))
			
			background = Crafty.background('#FFFFFF url(Graphics/ocean.png) repeat center center')
			fish = Crafty.e("2D, DOM, Image").image("Graphics/fish.png").origin("center")
			score = Crafty.e("2D, DOM, Text").attr({x:100, y: 10}).text("score text")
			//Crafty.e("2D, DOM, Image").image("Graphics/number_one.png").origin("center")
		}	
	</script>
</body>
</html>
